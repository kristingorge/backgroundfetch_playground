{"version":3,"sources":["../node_modules/idb/build/esm/wrap-idb-value.js","../node_modules/idb/build/esm/index.js","background_fetch.ts","sample_downloadable_items.ts","item_status.ts","background_fetch_manager.ts","downloadable_item.ts","db.ts","../node_modules/process/browser.js","sw.ts"],"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","then","value","set","catch","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","replaceTraps","callback","wrapFunction","func","transaction","includes","args","apply","unwrap","storeNames","call","sort","transformCachableValue","Proxy","IDBRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","store","index","shift","returnVal","oldTraps","cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","Array","arguments","i","push","title","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":";AAsLA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,EAAA,EAAA,QAAA,EAAA,EAAA,QAAA,EAAA,QAAA,EAAA,QAAA,OAAA,EAtLA,MAAMA,EAAgB,CAACC,EAAQC,IAAiBA,EAAaC,KAAMC,GAAMH,aAAkBG,GAE3F,IAAIC,EACAC,EAEJ,SAASC,IACGF,OAAAA,IACHA,EAAoB,CACjBG,YACAC,eACAC,SACAC,UACAC,iBAIZ,SAASC,IACGP,OAAAA,IACHA,EAAuB,CACpBK,UAAUG,UAAUC,QACpBJ,UAAUG,UAAUE,SACpBL,UAAUG,UAAUG,qBAiKhC,QAAA,EAAA,EA9JA,MAAMC,EAAmB,IAAIC,QACvBC,EAAqB,IAAID,QACzBE,EAA2B,IAAIF,QAC/BG,EAAiB,IAAIH,QACrBI,EAAwB,IAAIJ,QAClC,SAASK,EAAiBC,GAChBC,MAAAA,EAAU,IAAIC,QAAQ,CAACC,EAASC,KAC5BC,MAAAA,EAAW,KACbL,EAAQM,oBAAoB,UAAWC,GACvCP,EAAQM,oBAAoB,QAASE,IAEnCD,EAAU,KACZJ,EAAQM,EAAKT,EAAQU,SACrBL,KAEEG,EAAQ,KACVJ,EAAOJ,EAAQQ,OACfH,KAEJL,EAAQW,iBAAiB,UAAWJ,GACpCP,EAAQW,iBAAiB,QAASH,KAe/BP,OAbPA,EACKW,KAAMC,IAGHA,aAAiB3B,WACjBO,EAAiBqB,IAAID,EAAOb,KAI/Be,MAAM,QAGXjB,EAAsBgB,IAAIb,EAASD,GAC5BC,EAEX,SAASe,EAA+BC,GAEhCtB,GAAAA,EAAmBuB,IAAID,GACvB,OACEE,MAAAA,EAAO,IAAIjB,QAAQ,CAACC,EAASC,KACzBC,MAAAA,EAAW,KACbY,EAAGX,oBAAoB,WAAYc,GACnCH,EAAGX,oBAAoB,QAASE,GAChCS,EAAGX,oBAAoB,QAASE,IAE9BY,EAAW,KACbjB,IACAE,KAEEG,EAAQ,KACVJ,EAAOa,EAAGT,OAAS,IAAIa,aAAa,aAAc,eAClDhB,KAEJY,EAAGN,iBAAiB,WAAYS,GAChCH,EAAGN,iBAAiB,QAASH,GAC7BS,EAAGN,iBAAiB,QAASH,KAGjCb,EAAmBmB,IAAIG,EAAIE,GAkG/B,QAAA,EAAA,EAhGA,IAAIG,EAAgB,CAChBC,IAAIC,EAAQC,EAAMC,GACVF,GAAAA,aAAkBrC,eAAgB,CAE9BsC,GAAS,SAATA,EACA,OAAO9B,EAAmB4B,IAAIC,GAE9BC,GAAS,qBAATA,EACOD,OAAAA,EAAOG,kBAAoB/B,EAAyB2B,IAAIC,GAG/DC,GAAS,UAATA,EACOC,OAAAA,EAASC,iBAAiB,QAC3BC,EACAF,EAASG,YAAYH,EAASC,iBAAiB,IAItDlB,OAAAA,EAAKe,EAAOC,KAEvBX,IAAG,CAACU,EAAQC,EAAMZ,KACdW,EAAOC,GAAQZ,GACR,GAEXK,IAAG,CAACM,EAAQC,IACJD,aAAkBrC,iBACR,SAATsC,GAA4B,UAATA,IAGjBA,KAAQD,GAGvB,SAASM,EAAaC,GAClBT,EAAgBS,EAAST,GAE7B,SAASU,EAAaC,GAIdA,OAAAA,IAASlD,YAAYM,UAAU6C,aAC7B,qBAAsB/C,eAAeE,UAYvCD,IAA0B+C,SAASF,GAC5B,YAAaG,GAIT3B,OADPwB,EAAKI,MAAMC,EAAO,MAAOF,GAClB3B,EAAKhB,EAAiB8B,IAAI,QAGlC,YAAaa,GAGT3B,OAAAA,EAAKwB,EAAKI,MAAMC,EAAO,MAAOF,KAtB9B,SAAUG,KAAeH,GACtBnB,MAAAA,EAAKgB,EAAKO,KAAKF,EAAO,MAAOC,KAAeH,GAE3C3B,OADPb,EAAyBkB,IAAIG,EAAIsB,EAAWE,KAAOF,EAAWE,OAAS,CAACF,IACjE9B,EAAKQ,IAsBxB,SAASyB,EAAuB7B,GACxB,MAAiB,mBAAVA,EACAmB,EAAanB,IAGpBA,aAAiB1B,gBACjB6B,EAA+BH,GAC/BtC,EAAcsC,EAAO/B,KACd,IAAI6D,MAAM9B,EAAOS,GAErBT,GAEX,SAASJ,EAAKI,GAGNA,GAAAA,aAAiB+B,WACjB,OAAO7C,EAAiBc,GAGxBhB,GAAAA,EAAeqB,IAAIL,GACnB,OAAOhB,EAAe0B,IAAIV,GACxBgC,MAAAA,EAAWH,EAAuB7B,GAOjCgC,OAJHA,IAAahC,IACbhB,EAAeiB,IAAID,EAAOgC,GAC1B/C,EAAsBgB,IAAI+B,EAAUhC,IAEjCgC,EAEX,MAAMP,EAAUzB,GAAUf,EAAsByB,IAAIV,GAApD,QAAA,EAAA;;AC1GA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAAA,QAAA,OAAA,EAAA,OAAA,eAAA,QAAA,SAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,KAAA,OAAA,eAAA,QAAA,OAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,KA5EA,IAAA,EAAA,QAAA,uBAUA,SAASiC,EAAOC,EAAMC,GAAS,QAAEC,EAAF,QAAWC,EAAX,SAAoBC,EAApB,WAA8BC,GAAe,IAClEpD,MAAAA,EAAUqD,UAAUC,KAAKP,EAAMC,GAC/BO,GAAc,EAAKvD,EAAAA,GAAAA,GAgBlBuD,OAfHL,GACAlD,EAAQW,iBAAiB,gBAAkB6C,IACvCN,GAAQ,EAAKlD,EAAAA,GAAAA,EAAQU,QAAS8C,EAAMC,WAAYD,EAAME,YAAY,EAAK1D,EAAAA,GAAAA,EAAQkC,gBAGnFe,GACAjD,EAAQW,iBAAiB,UAAW,IAAMsC,KAC9CM,EACK3C,KAAM+C,IACHP,GACAO,EAAGhD,iBAAiB,QAAS,IAAMyC,KACnCD,GACAQ,EAAGhD,iBAAiB,gBAAiB,IAAMwC,OAE9CpC,MAAM,QACJwC,EAOX,SAASK,EAASb,GAAM,QAAEE,GAAY,IAC5BjD,MAAAA,EAAUqD,UAAUQ,eAAed,GAGlC,OAFHE,GACAjD,EAAQW,iBAAiB,UAAW,IAAMsC,MACvC,EAAKjD,EAAAA,GAAAA,GAASY,KAAK,SAAMgB,GAGpC,MAAMkC,EAAc,CAAC,MAAO,SAAU,SAAU,aAAc,SACxDC,EAAe,CAAC,MAAO,MAAO,SAAU,SACxCC,EAAgB,IAAIC,IAC1B,SAASC,EAAU1C,EAAQC,GACnB,KAAED,aAAkBzC,cAClB0C,KAAQD,GACM,iBAATC,EACP,OAEAuC,GAAAA,EAAczC,IAAIE,GAClB,OAAOuC,EAAczC,IAAIE,GACvB0C,MAAAA,EAAiB1C,EAAK2C,QAAQ,aAAc,IAC5CC,EAAW5C,IAAS0C,EACpBG,EAAUP,EAAa5B,SAASgC,GAEtC,KACEA,KAAmBE,EAAWpF,SAAWD,gBAAgBK,aACrDiF,IAAWR,EAAY3B,SAASgC,GAClC,OAEEI,MAAAA,EAAS,eAAgBC,KAAcpC,GAEnCnB,MAAAA,EAAK,KAAKiB,YAAYsC,EAAWF,EAAU,YAAc,YAC3D9C,IAAAA,EAASP,EAAGwD,MACZJ,IACA7C,EAASA,EAAOkD,MAAMtC,EAAKuC,UACzBC,MAAAA,QAAkBpD,EAAO2C,MAAmB/B,GAG3CwC,OAFHN,SACMrD,EAAGE,KACNyD,GAGJL,OADPP,EAAclD,IAAIW,EAAM8C,GACjBA,GAEX,EAAcM,EAAAA,GAAAA,IAAc,IACrBA,EACHtD,IAAK,CAACC,EAAQC,EAAMC,IAAawC,EAAU1C,EAAQC,IAASoD,EAAStD,IAAIC,EAAQC,EAAMC,GACvFR,IAAK,CAACM,EAAQC,MAAWyC,EAAU1C,EAAQC,IAASoD,EAAS3D,IAAIM,EAAQC;;ACrC5E,aArBD,IAAY,EAgBA,EAKX,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,sBAAA,QAAA,kCAAA,EAAA,QAAA,6BAAA,EArBD,SAAY,GAER,EAAA,EAAA,IAAA,GAAA,GAEA,EAAA,EAAA,QAAA,GAAA,UAEA,EAAA,EAAA,cAAA,GAAA,aAGA,EAAA,EAAA,eAAA,GAAA,cAEA,EAAA,EAAA,kBAAA,GAAA,iBAEA,EAAA,EAAA,2BAAA,GAAA,0BAbJ,CAAY,IAAA,QAAA,6BAAA,EAA4B,KAqBvC,QAAA,sBAAA,EALD,SAAY,GAAwB,EAAA,WAAA,GAAiB,EAAA,QAAA,UAAqB,EAAA,QAAA,UAA1E,CAAY,IAAA,QAAA,sBAAA,EAAqB;;ACd1B,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,MAAA,QAAA,MAAA,QAAA,YAAA,EArBA,MAAM,EAA2B,CACpC,GAAI,SACJ,SAAU,CAAC,iGACX,UAAW,SAkBR,QAAA,OAAA,EAZP,IAAI,EAA0B,GAC9B,IAAI,IAAI,EAAI,EAAG,EAAI,GAAI,IACnB,EAAc,gGACiF,SAG5F,MAAM,EAA0B,CACnC,GAAI,QACJ,SAAU,EACV,UAAW,UAGR,QAAA,MAAA,EAAA,MAAM,EAAQ,CAChB,CAAA,EAAO,IAAK,EACZ,CAAA,EAAM,IAAK,GAFT,QAAA,MAAA;;ACtBP,aAAA,IAAY,EAAZ,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,gBAAA,EAAA,QAAA,WAAA,EAAA,SAAY,GACR,EAAA,eAAA,iBACA,EAAA,YAAA,cACA,EAAA,OAAA,SACA,EAAA,WAAA,aAJJ,CAAY,IAAA,QAAA,WAAA,EAAU;;ACYrB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,6BAAA,EAAA,QAAA,6BAAA,EAAA,QAAA,0BAAA,EAXD,IAAI,EAA4D,KAC1D,SAAU,IACL,OAAA,EAGL,SAAU,EAA6B,GACzC,EAA4B,EAG1B,SAAU,IACJ,OAAA,EAAkC;;ACGI,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,uBAAA,EAflD,IAAA,EAAA,QAAA,sBACA,EAAA,QAAA,+BACA,EAAA,QAAA,QACA,EAAA,QAAA,iBACA,EAAA,QAAA,8BAWkD,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,IAAA,IAAA,EAAA,UAAA,SAAA,EAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,EAAA,EAAA,QAAA,EAAA,EAAA,MAAA,aAAA,EAAA,EAAA,IAAA,EAAA,SAAA,GAAA,EAAA,MAAA,KAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,EAAA,GAAA,KAAA,WAA5C,MAAO,UAA0B,YAmBnC,YAAY,GACR,QAEK,IAIA,KAAA,OAAS,EAAK,GACd,KAAA,OAAS,EAAW,WAAA,eACpB,KAAA,UAAY,KACZ,KAAA,YAAc,KACd,KAAA,kBAAoB,KACpB,KAAA,gBAAkB,MAvBvB,oBACI,OAAC,KAAK,gBAGH,KAAK,gBAAgB,WAAa,KAAK,gBAAgB,cAFnD,EAKX,WACO,OAAA,EAAM,MAAA,KAAK,QAkBhB,gBAlCwC,OAAA,EAAA,UAAA,OAAA,EAAA,YAmCrC,KAAA,UAAY,IAAI,KACf,MAAA,QAAY,EAA4B,EAAA,6BAAA,MAAM,KAAK,KAAK,GAAI,KAAK,KAAK,SAAU,CAClF,cAAe,KAAK,KAAK,UACzB,MAAO,KAAK,KAAK,KAEhB,KAAA,kBAAoB,EACpB,KAAA,kBAAkB,IACjB,EAAA,EAAA,OAAA,QAGJ,gBA7CwC,OAAA,EAAA,UAAA,OAAA,EAAA,YA8CtC,IAAC,KAAK,kBACA,KAAA,+BAGJ,KAAK,kBAAkB,QAExB,KAAA,OAAS,EAAW,WAAA,eACpB,KAAA,gBAAkB,MAEjB,EAAA,EAAA,OAAA,QAGJ,gBA1DwC,OAAA,EAAA,UAAA,OAAA,EAAA,YA2DrC,KAAA,UAAY,KACZ,KAAA,kBAAoB,KACpB,KAAA,kBAGD,kBAAkB,GACtB,EAAkB,iBAAiB,WAAa,GAAa,KAAK,uBAAuB,IAG7F,uBAAuB,GACf,EAAkB,QAAU,EAAsB,sBAAA,WAC7C,KAAA,OAAS,EAAW,WAAA,YAEpB,EAAkB,QAAU,EAAsB,sBAAA,SAClD,KAAA,OAAS,EAAW,WAAA,WAEpB,KAAK,cACD,KAAA,YAAc,IAAI,OAGtB,EAAkB,QAAU,EAAsB,sBAAA,UAClD,KAAA,OAAS,EAAW,WAAA,QAGxB,KAAA,gBAAkB,CACnB,cAAe,EAAkB,cACjC,WAAY,EAAkB,WAC9B,OAAQ,EAAkB,OAC1B,cAAe,EAAkB,eAEhC,KAAA,cAAc,IAAI,MAAM,mBAEvB,EAAA,EAAA,OAAA,MAGV,oBAAoB,EAAqB,EAAoC,GACpE,KAAA,OAAS,EAAQ,OACjB,KAAA,OAAS,EAAQ,OACjB,KAAA,UAAY,EAAQ,UACpB,KAAA,YAAc,EAAQ,YACtB,KAAA,kBAAoB,EACpB,KAAA,gBAAkB,EAAQ,gBAE3B,GACK,KAAA,kBAAkB,GAGtB,KAAA,cAAc,IAAI,MAAM,kBAGjC,gBACW,OAAA,KAAK,OAGhB,oBACW,MAAA,CACH,OAAQ,KAAK,OACb,QAAmC,MAA1B,KAAK,kBAA4B,KAAO,KAAK,kBAAkB,GACxE,OAAQ,KAAK,OACb,UAAW,KAAK,UAChB,YAAa,KAAK,YAClB,gBAAiB,KAAK,kBAxHgB,QAAA,kBAAA;;AC0EjD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,IAAA,EAAA,QAAA,OAAA,EAAA,QAAA,OAAA,EAAA,QAAA,MAAA,EAAA,QAAA,aAAA,EAvFD,IAAA,EAAA,EAAA,QAAA,QACA,EAAA,QAAA,uBACA,EAAA,QAAA,8BAqFC,SAAA,IAAA,GAAA,mBAAA,QAAA,OAAA,KAAA,IAAA,EAAA,IAAA,QAAA,OAAA,EAAA,WAAA,OAAA,GAAA,EAAA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,GAAA,OAAA,GAAA,iBAAA,GAAA,mBAAA,EAAA,MAAA,CAAA,QAAA,GAAA,IAAA,EAAA,IAAA,GAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,KAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,IAAA,IAAA,EAAA,UAAA,SAAA,EAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,EAAA,EAAA,QAAA,EAAA,EAAA,MAAA,aAAA,EAAA,EAAA,IAAA,EAAA,SAAA,GAAA,EAAA,MAAA,KAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,EAAA,GAAA,KAAA,WAhFK,SAAgB,EAAI,GAgFzB,OAAA,EAAA,UAAA,OAAA,EAAA,YA/ES,MAAA,QAAW,IACX,QAAY,EAAG,IAAI,QAAS,GAG9B,OAFJ,EAAG,QAEE,QAIQ,EAAa,EAAQ,GAHvB,OAMf,SAAe,EAAa,EAAoB,GAoE/C,OAAA,EAAA,UAAA,OAAA,EAAA,YAnES,MAAA,EAAqB,MAAf,EAAI,QAAkB,WAAa,EAA4B,EAAA,6BAAA,IAAI,EAAI,SAE7E,EAAK,IAAI,EAAJ,kBAGJ,OAFP,EAAG,oBAAoB,EAAY,EAAK,GAEjC,IAGL,SAAgB,IA2DrB,OAAA,EAAA,UAAA,OAAA,EAAA,YA1DS,MAAA,QAAW,IACX,QAAa,EAAG,OAAO,SAGtB,OAFP,EAAG,QAEI,QAAQ,IAAI,EAAK,IAAI,GAAK,EAAa,EAAE,OAAQ,OA8B5D,MAAM,EAAU,KAEV,SAAgB,IAsBrB,OAAA,EAAA,UAAA,OAAA,EAAA,YArBU,aAAM,EAAI,OAAO,EAAS,EAAG,CAChC,QAAQ,GACc,EAAG,kBAAkB,SAE7B,YAAY,cAAe,WAErC,EAAG,kBAAkB,iBAK3B,SAAgB,EAAM,GAU3B,OAAA,EAAA,UAAA,OAAA,EAAA,YATS,MAAA,QAAW,UACX,EAAG,IAAI,QAAS,EAAI,oBAAqB,EAAI,iBACnD,EAAG,UAGD,SAAgB,EAAa,EAAa,GAI/C,OAAA,EAAA,UAAA,OAAA,EAAA,YAHS,MAAA,QAAW,UACX,EAAG,IAAI,WAAY,EAAM,GAC/B,EAAG;;;ACvFP,IAOIqD,EACAC,EARAC,EAAUC,OAAOC,QAAU,GAU/B,SAASC,IACC,MAAA,IAAIC,MAAM,mCAEpB,SAASC,IACC,MAAA,IAAID,MAAM,qCAsBpB,SAASE,EAAWC,GACZT,GAAAA,IAAqBU,WAEdA,OAAAA,WAAWD,EAAK,GAGvB,IAACT,IAAqBK,IAAqBL,IAAqBU,WAEzDA,OADPV,EAAmBU,WACZA,WAAWD,EAAK,GAEvB,IAEOT,OAAAA,EAAiBS,EAAK,GAC/B,MAAME,GACA,IAEOX,OAAAA,EAAiBtC,KAAK,KAAM+C,EAAK,GAC1C,MAAME,GAEGX,OAAAA,EAAiBtC,KAAK,KAAM+C,EAAK,KAMpD,SAASG,EAAgBC,GACjBZ,GAAAA,IAAuBa,aAEhBA,OAAAA,aAAaD,GAGpB,IAACZ,IAAuBM,IAAwBN,IAAuBa,aAEhEA,OADPb,EAAqBa,aACdA,aAAaD,GAEpB,IAEOZ,OAAAA,EAAmBY,GAC5B,MAAOF,GACD,IAEOV,OAAAA,EAAmBvC,KAAK,KAAMmD,GACvC,MAAOF,GAGEV,OAAAA,EAAmBvC,KAAK,KAAMmD,MAjEhD,WACO,IAEIb,EADsB,mBAAfU,WACYA,WAEAL,EAEzB,MAAOM,GACLX,EAAmBK,EAEnB,IAEIJ,EADwB,mBAAjBa,aACcA,aAEAP,EAE3B,MAAOI,GACLV,EAAqBM,GAjB5B,GAwED,IAEIQ,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAaK,OACbJ,EAAQD,EAAaM,OAAOL,GAE5BE,GAAc,EAEdF,EAAMI,QACNE,KAIR,SAASA,IACDL,IAAAA,EAAAA,CAGAM,IAAAA,EAAUf,EAAWW,GACzBF,GAAW,EAGLO,IADFA,IAAAA,EAAMR,EAAMI,OACVI,GAAK,CAGA,IAFPT,EAAeC,EACfA,EAAQ,KACCE,EAAaM,GACdT,GACAA,EAAaG,GAAYO,MAGjCP,GAAc,EACdM,EAAMR,EAAMI,OAEhBL,EAAe,KACfE,GAAW,EACXL,EAAgBW,IAiBpB,SAASG,EAAKjB,EAAKkB,GACVlB,KAAAA,IAAMA,EACNkB,KAAAA,MAAQA,EAYjB,SAASC,KA5BT1B,EAAQ2B,SAAW,SAAUpB,GACrBnD,IAAAA,EAAO,IAAIwE,MAAMC,UAAUX,OAAS,GACpCW,GAAAA,UAAUX,OAAS,EACd,IAAA,IAAIY,EAAI,EAAGA,EAAID,UAAUX,OAAQY,IAClC1E,EAAK0E,EAAI,GAAKD,UAAUC,GAGhChB,EAAMiB,KAAK,IAAIP,EAAKjB,EAAKnD,IACJ,IAAjB0D,EAAMI,QAAiBH,GACvBT,EAAWc,IASnBI,EAAKnH,UAAUkH,IAAM,WACZhB,KAAAA,IAAIlD,MAAM,KAAM,KAAKoE,QAE9BzB,EAAQgC,MAAQ,UAEhBhC,EAAQiC,IAAM,GACdjC,EAAQkC,KAAO,GACflC,EAAQhC,QAAU,GAClBgC,EAAQmC,SAAW,GAInBnC,EAAQoC,GAAKV,EACb1B,EAAQqC,YAAcX,EACtB1B,EAAQsC,KAAOZ,EACf1B,EAAQuC,IAAMb,EACd1B,EAAQwC,eAAiBd,EACzB1B,EAAQyC,mBAAqBf,EAC7B1B,EAAQ0C,KAAOhB,EACf1B,EAAQ2C,gBAAkBjB,EAC1B1B,EAAQ4C,oBAAsBlB,EAE9B1B,EAAQ6C,UAAY,SAAU9E,GAAe,MAAA,IAE7CiC,EAAQ8C,QAAU,SAAU/E,GAClB,MAAA,IAAIqC,MAAM,qCAGpBJ,EAAQ+C,IAAM,WAAqB,MAAA,KACnC/C,EAAQgD,MAAQ,SAAUC,GAChB,MAAA,IAAI7C,MAAM,mCAEpBJ,EAAQkD,MAAQ,WAAoB,OAAA;;;ACpGpC,IAAA,EAAA,QAAA,WAlFA,EAAA,EAAA,QAAA,SAGA,EAAA,QAAA,8BA+EA,SAAA,IAAA,GAAA,mBAAA,QAAA,OAAA,KAAA,IAAA,EAAA,IAAA,QAAA,OAAA,EAAA,WAAA,OAAA,GAAA,EAAA,SAAA,EAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,GAAA,OAAA,GAAA,iBAAA,GAAA,mBAAA,EAAA,MAAA,CAAA,QAAA,GAAA,IAAA,EAAA,IAAA,GAAA,GAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,EAAA,OAAA,gBAAA,OAAA,yBAAA,IAAA,IAAA,KAAA,EAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAAA,CAAA,IAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,KAAA,OAAA,eAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,QAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,IAAA,IAAA,EAAA,UAAA,SAAA,EAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,EAAA,EAAA,QAAA,EAAA,EAAA,MAAA,aAAA,EAAA,EAAA,IAAA,EAAA,SAAA,GAAA,EAAA,MAAA,KAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,EAAA,GAAA,KAAA,WA9DA,SAAe,EAAY,GA8D3B,OAAA,EAAA,UAAA,OAAA,EAAA,YA7DU,MAAA,QAAmB,KAAK,QAAQ,SAAS,CAAC,KAAM,WACjD,IAAA,MAAM,KAAU,EACjB,EAAO,YAAY,KAI3B,SAAe,EAA2B,GAuD1C,OAAA,EAAA,UAAA,OAAA,EAAA,kBAtDU,EAAY,CACd,UAAW,EAAM,KACjB,GAAI,EAAM,aAAa,GACvB,WAAY,EAAM,aAAa,WAC/B,cAAe,EAAM,aAAa,cAClC,SAAU,EAAM,aAAa,SAC7B,YAAa,EAAM,aAAa,YAChC,cAAe,EAAM,aAAa,kBA5B1C,KAAK,iBAAiB,UAAY,IAG9B,EAAM,UAAU,KAAK,iBAKzB,KAAK,iBAAiB,WAAY,IAC9B,EAAM,UAAU,KAAK,QAAQ,WAuBjC,KAAK,iBAAiB,uBAAyB,IAC3C,EAAM,UAAU,EAA2B,MAG/C,KAAK,iBAAiB,yBAAiC,GAAc,OAAA,OAAA,OAAA,EAAA,YAC3D,MAAA,EAAe,EAAM,cAEtB,EAAL,EAAA,kCACiC,EAAA,EAAA,8BAAA,KAAK,cA4BtC,EAAM,UAzBU,KAAW,OAAA,OAAA,OAAA,EAAA,YACjB,MAAA,QAAgB,EAAa,iBAE7B,QAAQ,IAAI,EAAQ,IAAU,GAAS,OAAA,OAAA,OAAA,EAAA,YACrC,IACM,MAAA,QAAiB,EAAO,cACxB,QAAe,EAAS,cAE9B,QAAQ,wBAAwB,EAAS,aACnC,EAAG,aAAa,EAAS,IAAK,SAC9B,qBAA+B,EAAS,IAAI,UAAU,EAAS,IAAI,OAAS,OACpF,MAAO,GAEE,OADP,QAAQ,MAAM,mBAAqB,EAAO,QAAQ,IAAM,KAAO,EAAE,SAC1D,QAAQ,QAAQ,WAI/B,QAAQ,IAAI,8CACM,EAAG,IAAI,EAAa,KACnC,uBAAuB,GAE1B,QAAQ,IAAI,0CACZ,EAA2B,KAGf,OAGpB,KAAK,iBAAiB,sBAA8B,GAAc,OAAA,OAAA,OAAA,EAAA,YAC9D,EAAM,UAAU,EAA2B,OAG/C,KAAK,iBAAiB,uBAA+B,GAAc,OAAA,OAAA,OAAA,EAAA,YAC/D,EAAM,UAAU,EAA2B","file":"sw.js","sourceRoot":"../src","sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = await target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","export interface BackgroundFetchManager {\n    fetch(id: string, toFetch: RequestInfo | RequestInfo[], options: BackgroundFetchOptions): Promise<BackgroundFetchRegistration>;\n    get(id: string): Promise<BackgroundFetchRegistration|null>;\n    getIds(): Promise<string[]>;\n}\n\nexport interface ImageResource {\n    src: string;\n    sizes?: string;\n    type?: string;\n}\n\nexport interface BackgroundFetchUIOptions {\n    icons?: ImageResource[];\n    title?: string;\n}\n\nexport interface BackgroundFetchOptions extends BackgroundFetchUIOptions {\n    downloadTotal?: number;\n}\n\nexport enum BackgroundFetchFailureReason {\n    // The background fetch has not completed yet, or was successful.\n    \"\",\n    // The operation was aborted by the user, or abort() was called.\n    \"aborted\",\n    // A response had a not-ok-status.\n    \"bad-status\",\n    // A fetch failed for other reasons, e.g. CORS, MIX, an invalid partial response,\n    // or a general network failure for a fetch that cannot be retried.\n    \"fetch-error\",\n    // Storage quota was reached during the operation.\n    \"quota-exceeded\",\n    // The provided downloadTotal was exceeded.\n    \"download-total-exceeded\"\n};\n\nexport enum BackgroundFetchResult { InProgress = \"\", Success = \"success\", Failure = \"failure\" };\n\nexport interface BackgroundFetchRecord {\n    request: Request;\n    responseReady: Promise<Response>;\n};\n\n// from https://wicg.github.io/background-fetch/#background-fetch-registration\nexport interface BackgroundFetchRegistration extends EventTarget {\n    id: string;\n    uploadTotal: number;\n    uploaded: number;\n    downloadTotal: number;\n    downloaded: number;\n    result: BackgroundFetchResult;\n    failureReason: BackgroundFetchFailureReason;\n    recordsAvailable: boolean;\n\n    abort(): Promise<boolean>;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<BackgroundFetchRecord>;\n    matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise<Array<BackgroundFetchRecord>>;\n}\n","import { DownloadableItem } from \"./downloadable_item\";\n\nexport const SINGLE: DownloadableItem = {\n    id: 'single',\n    segments: ['https://bitmovin-a.akamaihd.net/content/MI201109210084_1/video/720_2400000/dash/segment_0.m4s'],\n    totalSize: 1434989\n};\n\n// Triggering different background fetch scenarios for testing purposes.\n// Test video files are from https://bitmovin.com/demos/stream-test\n\nlet videoSegments: string[] = [];\nfor(let i = 0; i < 50; i++) {\n    videoSegments.push(\n        `https://bitmovin-a.akamaihd.net/content/MI201109210084_1/video/720_2400000/dash/segment_${i}.m4s`);\n}\n\nexport const MULTI: DownloadableItem = {\n    id: 'multi',\n    segments: videoSegments,\n    totalSize: 61626553\n};\n\nexport const ITEMS = {\n    [SINGLE.id]: SINGLE,\n    [MULTI.id]: MULTI\n}\n","\nexport enum ItemStatus {\n    NOT_DOWNLOADED = 'not_downloaded',\n    DOWNLOADING = 'downloading',\n    FAILED = 'failed',\n    DOWNLOADED = 'downloaded'\n}\n","import { BackgroundFetchManager } from \"./background_fetch\";\n\nlet serviceWorkerRegistration: ServiceWorkerRegistration|null = null;\nexport function getServiceWorkerRegistration(): ServiceWorkerRegistration {\n    return serviceWorkerRegistration!;\n}\n\nexport function setServiceWorkerRegistration(swr: ServiceWorkerRegistration): void {\n    serviceWorkerRegistration = swr;\n}\n\nexport function getBackgroundFetchManager(): BackgroundFetchManager {\n    return (serviceWorkerRegistration as any).backgroundFetch as BackgroundFetchManager;\n}\n\n","import { BackgroundFetchRegistration, BackgroundFetchResult } from \"./background_fetch\";\nimport { ITEMS } from \"./sample_downloadable_items\";\nimport { store, IDbStorable, DownloadableStateDocument } from \"./db\";\nimport { ItemStatus } from \"./item_status\";\nimport { getBackgroundFetchManager } from \"./background_fetch_manager\";\n\nexport type DownloadableItemId = string;\n\nexport interface DownloadableItem {\n    id: DownloadableItemId;\n    segments: RequestInfo[];\n    totalSize: number;\n}\n\n\nexport class DownloadableState extends EventTarget implements IDbStorable {\n    itemId!: DownloadableItemId;\n    status!: ItemStatus;\n    startedAt!: Date|null;\n    completedAt!: Date|null;\n    fetchRegistration!: BackgroundFetchRegistration|null;\n    backgroundFetch!: Pick<BackgroundFetchRegistration, \"result\" | \"failureReason\" | \"downloaded\" | \"downloadTotal\">|null;\n\n    get downloadedPct(): number {\n        if (!this.backgroundFetch) {\n            return 0;\n        }\n        return this.backgroundFetch.downloaded / this.backgroundFetch.downloadTotal;\n    }\n\n    get item(): DownloadableItem {\n        return ITEMS[this.itemId];\n    }\n\n    constructor(item?: DownloadableItem) {\n        super();\n\n        if (!item) {\n            return;\n        }\n\n        this.itemId = item.id;\n        this.status = ItemStatus.NOT_DOWNLOADED;\n        this.startedAt = null;\n        this.completedAt = null;\n        this.fetchRegistration = null;\n        this.backgroundFetch = null;\n    }\n\n    async startDownload() {\n        this.startedAt = new Date();\n        const reg = await getBackgroundFetchManager().fetch(this.item.id, this.item.segments, {\n            downloadTotal: this.item.totalSize,\n            title: this.item.id\n        });\n        this.fetchRegistration = reg;\n        this.addFetchListeners(reg);\n        store(this);\n    }\n\n    async abortDownload() {\n        if (!this.fetchRegistration) {\n            throw 'no fetch registration!';\n        }\n\n        await this.fetchRegistration.abort();\n\n        this.status = ItemStatus.NOT_DOWNLOADED;\n        this.backgroundFetch = null;\n    \n        store(this);\n    }\n\n    async retryDownload() {\n        this.startedAt = null;\n        this.fetchRegistration = null;\n        this.startDownload();\n    }\n\n    private addFetchListeners(fetchRegistration: BackgroundFetchRegistration) {\n        fetchRegistration.addEventListener('progress', (e: Event) => this.updateFromRegistration(fetchRegistration));\n    }\n\n    updateFromRegistration(fetchRegistration: BackgroundFetchRegistration) {\n        if (fetchRegistration.result == BackgroundFetchResult.InProgress) {\n            this.status = ItemStatus.DOWNLOADING;\n        }\n        else if (fetchRegistration.result == BackgroundFetchResult.Success) {\n            this.status = ItemStatus.DOWNLOADED;\n\n            if (!this.completedAt) {\n                this.completedAt = new Date();\n            }\n        }\n        else if (fetchRegistration.result == BackgroundFetchResult.Failure) {\n            this.status = ItemStatus.FAILED;\n        }\n\n        this.backgroundFetch = {\n            downloadTotal: fetchRegistration.downloadTotal,\n            downloaded: fetchRegistration.downloaded,\n            result: fetchRegistration.result,\n            failureReason: fetchRegistration.failureReason,\n        };\n        this.dispatchEvent(new Event('requestrender'));\n\n        store(this);\n    }\n\n    fromStorageDocument(_storageKey: string, dbState: DownloadableStateDocument, fetchRegistration: BackgroundFetchRegistration|null) {\n        this.itemId = dbState.itemId;\n        this.status = dbState.status;\n        this.startedAt = dbState.startedAt;\n        this.completedAt = dbState.completedAt;\n        this.fetchRegistration = fetchRegistration;\n        this.backgroundFetch = dbState.backgroundFetch;\n\n        if (fetchRegistration) {\n            this.addFetchListeners(fetchRegistration);\n        }\n\n        this.dispatchEvent(new Event('requestrender'));\n    }\n\n    idbStorageKey() {\n        return this.itemId;\n    }\n\n    toStorageDocument() {\n        return {\n            itemId: this.itemId,\n            fetchId: this.fetchRegistration == null ? null : this.fetchRegistration.id,\n            status: this.status,\n            startedAt: this.startedAt,\n            completedAt: this.completedAt,\n            backgroundFetch: this.backgroundFetch\n        };\n    }\n}\n\n","// indexed db helper file\n\nimport * as idb from 'idb';\nimport { DownloadableItemId, DownloadableState } from './downloadable_item';\nimport { getBackgroundFetchManager } from './background_fetch_manager';\nimport { ItemStatus } from './item_status';\nimport { BackgroundFetchRegistration } from './background_fetch';\n\n\nexport async function get(itemId: DownloadableItemId): Promise<IDbStorable|null> {\n    const db = await openDb();\n    const doc = await db.get('items', itemId);\n    db.close();\n\n    if (!doc) {\n        return null;\n    }\n\n    return await stateFromDoc(itemId, doc);\n}\n\nasync function stateFromDoc(storageKey: string, doc: DownloadableStateDocument) {\n    const reg = doc.fetchId == null ? null : await getBackgroundFetchManager().get(doc.fetchId);\n\n    const dl = new DownloadableState();\n    dl.fromStorageDocument(storageKey, doc, reg);\n\n    return dl;\n} \n\nexport async function getAll(): Promise<IDbStorable[]> {\n    const db = await openDb();\n    const docs = await db.getAll('items');\n    db.close();\n\n    return Promise.all(docs.map(d => stateFromDoc(d.itemId, d)));\n}\n\nexport interface DownloadableStateDocument {\n    fetchId: string|null;\n    itemId: string;\n    startedAt: Date|null;\n    completedAt: Date|null;\n    status: ItemStatus;\n    backgroundFetch: Pick<BackgroundFetchRegistration, \"result\" | \"failureReason\" | \"downloaded\" | \"downloadTotal\">|null;\n}\n\nexport interface IDbStorable {\n    fromStorageDocument(_storageKey: string, dbState: DownloadableStateDocument, fetchRegistration: BackgroundFetchRegistration|null): void;\n    idbStorageKey(): string;\n    toStorageDocument(): DownloadableStateDocument;\n}\n\nexport interface TestDB extends idb.DBSchema {\n    items: {\n        key: string;\n        value: DownloadableStateDocument;\n        indexes: { 'by-fetch-id': 'fetchId' };\n    },\n    segments: {\n        key: string;\n        value: ArrayBuffer;\n    }\n}\n\nconst DB_NAME = 'db';\n\nexport async function openDb() {\n    return await idb.openDB(DB_NAME, 1, {\n        upgrade(db) {\n            const itemStore = db.createObjectStore('items');\n\n            itemStore.createIndex('by-fetch-id', 'fetchId');\n\n            db.createObjectStore('segments');\n        }\n    });;\n}\n\nexport async function store(obj: IDbStorable) {\n    const db = await openDb();\n    await db.put('items', obj.toStorageDocument(), obj.idbStorageKey());\n    db.close();\n}\n\nexport async function storeSegment(url: string, data: ArrayBuffer) {\n    const db = await openDb();\n    await db.put('segments', data, url);\n    db.close();\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import { } from \".\";\nimport * as db from \"./db\";\nimport { BackgroundFetchRegistration } from \"./background_fetch\";\nimport { DownloadableState } from \"./downloadable_item\";\nimport { setServiceWorkerRegistration, getServiceWorkerRegistration } from \"./background_fetch_manager\";\n\ndeclare var self: ServiceWorkerGlobalScope;\n\nself.addEventListener(\"install\", (event: ExtendableEvent) => {\n    // Use waitUntil to make sure the ServiceWorker doesn't accidentally get killed by the browser.\n    // Skip waiting to install latest version since there are no breaking change right now.\n    event.waitUntil(self.skipWaiting());\n});\n\n// Claim ownership over the parent page without waiting for a new navigation event. This reduces having to reload\n// during development.\nself.addEventListener('activate', event => {\n    event.waitUntil(self.clients.claim());\n});\n\n// Post message to all open tabs associated with this ServiceWorker.\nasync function postMessage(msg: any) {\n    const allClients = await self.clients.matchAll({type: 'window'});\n    for (const client of allClients) {\n        client.postMessage(msg);\n    }\n}\n\nasync function handleBackgroundFetchEvent(event: any) {\n    await postMessage({\n        eventType: event.type,\n        id: event.registration.id,\n        downloaded: event.registration.downloaded,\n        downloadTotal: event.registration.downloadTotal,\n        uploaded: event.registration.uploaded,\n        uploadTotal: event.registration.uploadTotal,\n        failureReason: event.registration.failureReason,\n    });\n}\n\nself.addEventListener('backgroundfetchclick', (event: any) => {\n    event.waitUntil(handleBackgroundFetchEvent(event));\n});\n\nself.addEventListener('backgroundfetchsuccess', async (event: any) => {\n    const registration = event.registration as BackgroundFetchRegistration;\n\n    if (!getServiceWorkerRegistration()) {\n        setServiceWorkerRegistration(self.registration);\n    }\n\n    const process = async () => {\n        const records = await registration.matchAll();\n        \n        await Promise.all(records.map(async record => {\n            try {\n                const response = await record.responseReady;\n                const buffer = await response.arrayBuffer();\n\n                console.log(`Storing segment: ${response.url}`);\n                await db.storeSegment(response.url, buffer);\n                await postMessage(`Stored data for ${response.url.substring(response.url.length - 20)}`);    \n            } catch (e) {\n                console.error('No response for ' + record.request.url + ': ' + e.message);\n                return Promise.resolve(null);\n            }\n        }));\n\n        console.log(`updating download state to complete`);\n        const dl = (await db.get(registration.id)) as DownloadableState;\n        dl.updateFromRegistration(registration);\n\n        console.log(`sending background fetch success event`);\n        handleBackgroundFetchEvent(event);\n    };\n\n    event.waitUntil(process());\n});\n\nself.addEventListener('backgroundfetchfail', async (event: any) => {\n    event.waitUntil(handleBackgroundFetchEvent(event));\n});\n\nself.addEventListener('backgroundfetchabort', async (event: any) => {\n    event.waitUntil(handleBackgroundFetchEvent(event));\n});"]}